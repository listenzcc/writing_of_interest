\input{settings-all-in-one}

\title{Better Programming}
\author{Chuncheng Zhang}

\begin{document}

\maketitle

\abstract
Every one has \emph{computer}.
It computes at a very high speed.
Basically, you put your data in \emph{objects}, and generate \emph{functions} to do the computation.
The \emph{languages} are the communication between you and the computer.
And the \emph{algorithms} are the tools of how to do the computation precisely and quickly.
A good \emph{programming} is about all of the above,
you have to manage them, like the arm controls the hand.

\tableofcontents

\newpage
\section{Computer}

The computer is PC or laptop in real-world.
But in programming, the computer can be a very \emph{abstraction} concept.
Four components are necessary:
\begin{itemize}
    \item Input \\ Used for user input
    \item Output \\ Used for output to screen or speaker
    \item Memory \\ Where the variables stay during computing
    \item Disk \\ Where the files stay forever
\end{itemize}

\subsection{Input \& Output}

The input and output are the interfaces between the computer and users.
Input means message from user to computer, and output means the reverse.
They are applied in different syntax in different language.
Take \emph{Python} and \emph{JavaScript} for examples.

\lstinputlisting[
    style       =   Python,
    caption     =   {InputOutput.py},
    label       =   {InputOutput.py}
]{./src/Computer/InputOutput.py}

\lstinputlisting[
    style       =   JavaScript,
    caption     =   {InputOutput.js},
    label       =   {InputOutput.js}
]{./src/Computer/InputOutput.js}

\subsection{Memory}

When you practice programming,
all the variables, functions and objects in your code is in the memory.
In another word, the computation equals to the operation to the memory.
More about memory can be found in the section of Objects.
In current stage, all you need to know is everything you program is in the memory.

\subsection{Disk}

When computing is finished,
users may have their stuff to be stored forever.
The disk is where to put them.

It should be noticed that it can be very different between the things in memory and their storage in disk.
For example, an article is structured as a characters array in the memory.
However, it is stored as a highly compressed binary series in the disk.
Although the difference between the two formats,
they are the same article in fact.

At the viewpoint of the memory, there are fine programs to save the data to and read the data from the disk.
In ideal condition, the two-way process is \emph{transparent} to the user,
which it frees the users to think about the conversion,
thus the users can focus on the object in memory during computation.

\section{Objects}

The object is an overall calling to the things of interest.
It can be a number, character, string, list or set.
Moreover, it can even be a collection of them.

When you are thinking about a object,
you are actually summarizing its features in the mind.
But the computer works in the real world.
That is a large separation.
\begin{quote}
    \emph{In the abstraction level}, the object is the summary of features.
    \emph{And in the concrete level}, the object is an instance of features.
\end{quote}
The gap causes several problems.

Basically, a number has two features, the value and the precision.
In abstraction level, $100/3$ is an existing number.
However, in the real world, the computer can not represent it with infinite precision.
As a result, every time you put your hand to it in the program,
it shows as the given precision, and the output value can be different.

\lstinputlisting[
    style       =   JavaScript,
    caption     =   {Precision.js},
    label       =   {Precision.js}
]{./src/Objects/Precision.js}

Fortunately, the \emph{float} precision is far beyond to meet the standard of daily usage.
Evenly, in modern programming language, like JavaScript and Python,
the precision can be intelligent assigned to the variables without causing problems in most cases,
which is largely convenience to the users.

The effect of precision is only a small piece of the difference between the object in your mind and its instance in your computer.
Keep it in your mind when practicing the programming, and it will save your from lots of unnecessary troubles.

\subsection{Data Organization}

Before you do anything with your computer,
you need to understand the organization of data,
since it may be too large to look at and place them one-by-one.
Moreover, the data can be arbitrary on the using end.
A good program is designed to deal with different values and sizes in the given data structure.
As a result, the first thing of programming is in two folder:
\begin{itemize}
    \item Decide how to organize the data;
    \item Estimate how long the operation will take at typical situation.
\end{itemize}
Does it look like two things?
Yes, but actually No.
I believe they are from one thing with the name of \emph{Data Structure}.
Before actually enter into the field of data structure, the data organization is easier to understand.

Think of a simple program to score the kids with their raw scores.

\lstinputlisting[
    style       =   JavaScript,
    caption     =   {Score.js},
    label       =   {Score.js}
]{./src/Objects/Score.js}

The script can be used to generate discrete scores based on the raw scores.
As it writes, one can tell the discrete score based on the raw score value using the threshold table.
It is quite short and simple.
But it contains two classic data structures, the coder can solve more than 80\% computation problems with them.
They are \emph{chain list} and \emph{hash table}.

\subsubsection{Chain List}

A chain list contains countless nodes,
the length can be very large.
They are linked one after another like the nodes in a chain.
It is almost the simplest data structure in the computer.
The advantage is memory saving and easy to access to certain position,
and the pitfall is it can be slow for query the certain value.

\lstinputlisting[
    style       =   Javascript,
    caption     =   {Array.js},
    label       =   {Array.js}
]{./src/Objects/Array.js}

The code describes the thing.
It can be time consuming to find out if certain value exists.
Commonly, it will find it after too many operations or report it can not be found in the list.
At the worst condition, the computer has to check every node in the chain list to find the given value.
As a result, the expectation of the time consuming is
\begin{equation}
    \label{Eq: cc-o1}
    \mathcal{O}(n)
\end{equation}
where $n$ refers the length of the chain list.
It is a common notion of time consuming estimation in the field of \emph{computational complexity}.

\begin{quote}
    Computational complexity!
    As we know, Computation is the process of calculating something by mathematical or logical methods.
    Execution of an algorithm is a well-known example of computation.
    In order to perform any sort of computation, we will need energy.
    This energy can be directly related to the resources that we spend to perform computation.

    \flushright{\textit{Data from: Wikipedia}}
\end{quote}

It refers the time consuming can be estimated by $n$
\begin{equation*}
    \mathcal{E}(t) \propto f(n) + c
\end{equation*}
where $f(\cdot)$ refers a linear function, and $c$ is constant independent with $n$.
As a result, when the $n$ is too large, the program may use up countless computation times.

No one wants to wait almost forever to just find out some value.
The question is how to speed up the process?
The hash table is one solution.

\subsubsection{Hash Table}

The thresholds in Listing \ref{Score.js} is a hash table.
As it writes, the elements in the hash table has two factors:
\begin{itemize}
    \item Key: The unique key to access the record;
    \item Value: The value belonging to the key.
\end{itemize}
The hash table is used for quickly access to the value by certain key.

The idea of hash table is to use its hash value to identify the key and thus find its value.
Since the key's location is computed rather than searched by exhaustively search
\footnote{
    Exhaustively search: Including or considering all elements or aspects; fully comprehensive.
    Like search one-by-one in a chain list.
}.
The process can be expressed as
\begin{align*}
    h & = \mathbb{H} (key) \\
    i & = \mathbb{L}_n (h)
\end{align*}
where $\mathbb{H}$ is hash function to compute the hash value
\footnote{
    Hash value is usually a string.
},
and $\mathbb{L}_n$ is projection function to compute its location $i$ in the $n$ sized hash table.
A qualified hash system of $(\mathbb{H}, \mathbb{L}_n$ can map the keys into the hash table evenly.
That says the keys will be located to $n$ locations with equal probability.

Using the hash method, the key-value pairs are separated evenly into the $n$ length hash table.
When query a key, the program only has to compute its hash value and find it from the location.
Assume there $m$ pairs in the hash table, the computation complexity is
\begin{equation}
    \label{Eq: cc-o2}
    \mathcal{O}(\frac{m}{n})
\end{equation}
The computation is because the exhaustively search process only has to deal with the list with length of $\frac{m}{n}$ in ideal condition
\footnote{
    Ideal refers the hash function is qualified.
}.
As a result, the hash table is commonly used for storage large data for arbitrary query.

Below is an example for explanation.

\lstinputlisting[
    style       =   Javascript,
    caption     =   {HashTable.js},
    label       =   {HashTable.js}
]{./src/Objects/HashTable.js}

\subsubsection{Conclusion}

The chain list or hash table are two common structures.
The chain list is simple and memory save.
It is commonly used for the circumstances that users are only concern to enumerate the values but not query certain value.
The hash table is more complex with the hash function.
It is more suitable for the circumstances that it is necessary for query arbitrary keys.
The speed up for the query is several times depending on the size of hash table.
It shows the chosen of data structure may largely affect the performance of the program.
As a result, the data structure research is to develop better structure for certain circumstances.

\subsection{Data Structure}

There are huge number of customized data structure.
They can be classified into two main classes
\begin{itemize}
    \item Stack: One dimensional ordered list;
    \item Heap: Other than stack, mostly likes a tree.
\end{itemize}
Since the data structure is goal driven, the combine of the different structures is most used.
For example, the hash table in Listing \ref{HashTable.js} is a combination of heap and stack.
The outer table is a heap, and its inner elements are stacks.

\subsubsection{Stack}

\subsubsection{Heap}

\section{Functions}

\section{Languages}

\section{Algorithms}

\appendix

\section{Computation Complexity}

\end{document}